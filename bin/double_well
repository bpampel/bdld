#!/usr/bin/env python3
"""Run bdld simulation on a 1d double-well potential"""

import argparse
import numpy as np
from typing import List

from bdld import analysis
from bdld.bdld import BirthDeathLangevinDynamics
from bdld.bussi_parinello_ld import BussiParinelloLD
from bdld.potential import Potential


def parse_cliargs() -> argparse.Namespace:
    """Use argparse to get cli arguments
    :return: args: Namespace with cli arguments"""

    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-kT",
        "--temp",
        type=float,
        dest="kt",
        help="Energy (in units of kT) of the FES file",
        required=True,
    )
    parser.add_argument(
        "-g", "--friction", type=float, help="Friction coefficient", required=True
    )
    parser.add_argument(
        "-dt",
        "--time-step",
        type=float,
        dest="time_step",
        help="Time step",
        required=True,
    )
    parser.add_argument(
        "-nw",
        "--num-walkers",
        type=int,
        dest="num_walkers",
        default=50,
        help="Number of walkers to put in each minimum, defaults to 50",
    )
    parser.add_argument(
        "-w1",
        "--frac-walkers-first-state",
        type=float,
        dest="walkers_frac",
        default=0.5,
        help="Fraction of walkers to put in first minimum (1 is all in first, "
        "0 is all in second, will be rounded in favor of first)",
    )
    parser.add_argument(
        "--num-steps", type=int, dest="num_steps", help="Time step", required=True
    )
    parser.add_argument(
        "-bw",
        "--kernel-bandwidth",
        type=float,
        dest="bw",
        nargs="+",
        help="Bandwidth for gaussian kernels",
    )
    parser.add_argument(
        "--birth-death-stride",
        type=int,
        dest="bd_stride",
        help="Stride for the birth-death processes",
        default=0,
    )
    parser.add_argument(
        "--random-seed",
        type=int,
        dest="seed",
        help="Seed for the random number generator",
    )
    parser.add_argument(
        "--trajectory-files",
        dest="traj_files",
        help="Filename (prefix) to write the trajectories to. Will not save them if empty",
    )
    parser.add_argument(
        "--fes-file", dest="fes_file", help="Save fes data to given path"
    )
    parser.add_argument(
        "--fes-image",
        dest="fes_image",
        help="Save fes image to given path. If not specified it will show the image and ask for the name.",
    )
    parser.add_argument(
        "--tilt",
        type=float,
        help="Tilt of the one-dimensional potential (linear coefficient)",
    )
    parser.add_argument(
        "--log-stride",
        type=int,
        dest="log_stride",
        default=0,
        help="Print information every n time steps",
    )
    parser.add_argument(
        "--omit-initial",
        type=int,
        dest="omit_initial",
        default=0,
        help="Number of initial time steps to omit in Histogram",
    )
    parser.add_argument(
        "-kde",
        "--kernel-density-estimate",
        action="store_true",
        dest="kde",
        default=False,
        help="Use KDE for density estimate",
    )
    parser.add_argument(
        "--kernel-correction-file",
        type=str,
        dest="kernel_correction_file",
        help="Save the probability correction grid due to the gaussian kernels to the given path",
    )

    args = parser.parse_args()
    if args.bd_stride != 0 and args.bw is None:
        raise ValueError(
            "Error: Bandwidth for birth-death kernels not specified. (-bw argument)"
        )
    return args


def main() -> None:
    args = parse_cliargs()

    # double well potential with optional tilt
    pot = Potential(np.array([0, float(args.tilt or 0.0), -4, 0, 1]), [(-2.5, 2.5)])

    # set up LD and add particles
    ld = BussiParinelloLD(
        pot,
        args.time_step,
        args.friction,
        args.kt,
        args.seed,
    )
    # minumum slightly changes with tilt, calculate from coefficients
    extrema = np.polynomial.polynomial.polyroots(*ld.pot.der)  # includes also maximum
    # add particles, round in favor of first state
    for _ in range(int(np.ceil(args.num_walkers * args.walkers_frac))):
        ld.add_particle([extrema[0]])
    for _ in range(int(args.num_walkers * (1 - args.walkers_frac))):
        ld.add_particle([extrema[2]])
    print(
        f"Added {args.num_walkers} walkers with a distribution ratio of {args.walkers_frac}"
    )
    print()

    if args.seed is not None:
        args.seed += 1000
    bdld = BirthDeathLangevinDynamics(ld, args.bd_stride, args.bw, args.seed, args.kde)

    if args.kernel_correction_file:
        print(f"Saving correction grid due to kernel to: {args.kernel_correction_file}")
        bdld.bd.prob_correction_kernel.write_to_file(args.kernel_correction_file)

    print(
        f"Running for {args.num_steps} timesteps with a birth/death stride of {args.bd_stride}"
    )
    if args.traj_files:
        print(f"Saving trajectories to: {args.traj_files}.i")
        init_histo_and_traj_files(
            bdld,
            False,
            [args.traj_files + "." + str(i) for i in range(args.num_walkers)],
        )
    if args.log_stride == 0:
        bdld.run(args.omit_initial)  # might be 0 steps
        init_histo_and_traj_files(bdld, True)  # init histo again to overwrite previous
        bdld.run(args.num_steps - args.omit_initial)
    else:
        if args.omit_initial <= args.log_stride:
            bdld.run(args.omit_initial)
            init_histo_and_traj_files(bdld, True)
            # run until log_stride is met
            bdld.run(args.log_stride - args.omit_initial)
            print_stats(args.log_stride, bdld)
            passed_steps = args.log_stride
        else:
            log_iters = args.omit_initial // args.log_stride
            for i in range(log_iters):
                bdld.run(args.log_stride)
                print_stats((i + i) * args.log_stride, bdld)
            bdld.run(args.omit_initial % args.log_stride)
            init_histo_and_traj_files(bdld, True)
            # run until log stride is met
            bdld.run(args.log_stride - (args.omit_initial % args.log_stride))
            passed_steps = (log_iters + i) * args.log_stride
            print_stats(passed_steps, bdld)
        remaining_steps = args.num_steps - passed_steps
        for i in range(remaining_steps // args.log_stride):
            bdld.run(args.log_stride)
            print_stats((i + 1) * args.log_stride + passed_steps, bdld)
        bdld.run(remaining_steps % args.log_stride)

    print("\nFinished simulation")
    if args.bd_stride != 0:
        bdld.bd.print_stats()

    if args.fes_file:
        print(f"Saving fes data to: {args.fes_file}")
        bdld.save_fes(args.fes_file)
    if args.fes_image:
        print(f"Saving fes image to: {args.fes_image}")
    plot_title = "bw " + str(args.bw[0]) if args.bd_stride != 0 else "Pure LD"
    bdld.plot_fes(args.fes_image, plot_domain=(-0.5, 8.0), plot_title=plot_title)

    # simply divide states by the 0 line for deltaF analysis
    delta_f_masks = [bdld.histo.bin_centers()[0] < 0, bdld.histo.bin_centers()[0] > 0]
    delta_f = analysis.calculate_delta_f(bdld.histo.fes, args.kt, delta_f_masks)[0]
    delta_f_ref = analysis.calculate_delta_f(
        ld.pot.calculate_reference(bdld.histo.points()),
        args.kt,
        delta_f_masks,
    )[0]
    print(f"Delta F: {delta_f:.4} (ref: {delta_f_ref:.4})")


def print_stats(step: int, bdld: BirthDeathLangevinDynamics) -> None:
    """Print stats from specified bdld)"""
    if bdld.bd:
        print(f"After {step} time steps:")
        bdld.bd.print_stats()
        print("", flush=True)


def init_histo_and_traj_files(
    bdld: BirthDeathLangevinDynamics,
    clear_traj: bool = False,
    traj_files: List[str] = None,
) -> None:
    """Initialize or reset histogram and optionally initialize trajectories"""
    if traj_files:
        bdld.init_traj_files(traj_files)
    if clear_traj:
        bdld.save_traj(clear=True)
    bdld.init_histo([200], [(-2.5, 2.5)])


if __name__ == "__main__":
    main()
